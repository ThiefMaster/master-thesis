\section{Indico}

Das derzeit in Indico verwendete System kann zwar grob als Framework betrachtet werden, ist jedoch
nicht wirklich ein Framework, da sehr viele Dinge speziell auf die Anwendung zugeschnitten sind,
statt generischen bzw. wiederverwendbaren zu sein. Dies ist bereits daran zu erkennen, dass sich der
Frameworkcode nicht in einem separaten Modul oder Package befindet sondern Teil der Indico-Codebasis
ist.

Den Kern des Frameworks bildet das Package \lstinline{indico.web.wsgi}, welches das in
\autoref{wsgi-interface} beschriebene WSGI-Interface implementiert und Emulationsschicht für
\emph{mod\_python} bereitstellt. Neben dem Bereitstellen der entsprechenden APIs und Objekte ist due
wichtigste Aufgabe dieser Schicht, Requests auf die entsprechenden Python-Dateien zu mappen.
Beispielsweise führt ein Aufruf von \emph{/index.py/foo} zum Aufruf der Function \lstinline{foo()}
in der Datei \emph{index.py} im \emph{htdocs}-Ordner. Da diese Dateien jedoch - um das Verhalten von
\emph{mod\_python} beizubehalten - erst dann geladen werden, wenn ein entsprechender Request
empfangen wird, können sie nicht beim Initialisierung der Anwendung importiert und in einem Mapping
abgelegt werden. Stattdessen wird der gesamte Code der entsprechenden Datei in einen String geladen
und danach ausgeführt. \autoref{lst:mp-emulation} zeigt eine vereinfachte Version des dafür
zuständigen Codes.

\begin{lstlisting}[caption=Laden der Legacy-Python-Dateien,label=lst:mp-emulation]
def mp_legacy_publisher(req, module, handler):
    the_module = open(module).read()
    module_globals = {}
    exec(the_module, module_globals)
    return module_globals[handler](req, **req.form)
\end{lstlisting}

Bekanntermaßen ist es schlechter Stil, Code aus Strings auszuführen. In Python hat es darüberhinaus
noch den Nachteil, dass Debugger keinen Zugriff auf den Code haben, da sie nicht wissen, aus welcher
Datei der Code stammt, und Python den Quelltext selbst nicht zusammen mit dem Bytecode im Speicher
hält. In Indico ist dies allerdings kein größeres Problem, da die Dateien keine Logik enthalten
sondern nur die entsprechende Handlerfunktion aufrufen, allerdings ist es dennoch unsauber.

Neben diesen Legacy-Handlern, die jedoch für fast alle Bestandteile von Indico genutzt werden,
existiert ein sehr einfaches Routingsystem, das Anfragen anhand des ersten Pfadsegments der URL an
eine Handler-Funktion übergibt. Dies ist zwar prinzipiell besser, da so die Nutzung von
\lstinline{exec} vermieden werden könnte, allerdings wird letzendlich genau dieselbe zuvor schon
beschriebene Funktion verwendet, was leicht dazu verleitet, in der in \autoref{lst:lame-routing}
gezeigten Routingtabelle direkt auf die Handlerfunktion mit der eigentlichen Logik zu verweisen.
Dies führt dann allerdings dazu, dass das mit \lstinline{exec} verbundene Debuggingproblem plötzlich
auch relevanten Code betrifft statt nur einen einfachen Funktionsaufruf. Umgangen werden kann das
zum Glück sehr einfach, indem eine separate Python-Datei nur den Aufruf der eigentlichen
Handler-Funktion enthält und diese Datei in der Routingtabelle referenziert wird.

\begin{lstlisting}[caption=Einfaches URL-Routing,label=lst:lame-routing]
{'': ((self.htdocs_dir, 'index.py'), 'index', '', None),
 'services': ((DIR_SERVICES, 'handler.py'), 'handler', '', None),
 'export': ((DIR_MODULES, 'wsgi_handler.py'), 'handler', '', None),
 'api': ((DIR_MODULES, 'wsgi_handler.py'), 'handler', '', None)
}
\end{lstlisting}

Für die eigentliche Anwendungslogik sind die \lstinline{RH}-Klassen zuständig. Die Basisklasse
enthält dabei die Logik für die Datenbankverbindung und zum Abfangen von Fehlern, während die
Subklassen davon die eigentliche Anwendungslogik implementieren. Die Abgrenzung zwischen Framework
und Anwendung wird teilweise verwässert, da Teile der Basisklasse auf Anwendungscode zugreifen
während diverse andere nur Frameworkcode (in der Regel das \lstinline{req}-Objekt mit den
\emph{mod\_python})-Daten nutzen.

\begin{description}
\item[Modularität] \hfill \\
Indico enthält ein Modulsystem, welches sowohl für Code, der ein fester Bestandteil von Indico ist,
als auch für externen Code genutzt werden kann. In beiden Fällen bietet das Modulsystem einen
Namespace in der Datenbank, der ausschließlich vom jeweiligen Modul genutzt wird, und einen
Menüpunkt in der Administrationsoberfläche, über den das Modul aktiviert bzw. deaktiviert und
konfiguriert werden kann. Dies hat den großen Vorteil, dass die Konfiguration bei den meisten
Modulen sehr einfach ist - sowohl für die Administratoren als auch für den Entwickler.

Einige Module, beispielsweise das Interface zum CERN-Paymentsystem und zur CERN-Suchmaschine, sind
nicht Teil des Open-Source-Projekts. Daher muss es für solche Module eine Möglichkeit geben, auch
ohne direkt im Indico-Code referenziert zu werden, auf Datenstrukturen zugreifen und bei bestimmten
Ereignissen Code ausführen zu können. Dies wurde in Indico mithilfe von \emph{entry points}
realisiert. Dabei handelt es sich um ein Feature des Paketsystems von Python, über das ein Paket
Objekte für einen bestimmten \emph{entry point} zentral registrieren kann. Indico dann dann mit der
Funktion \lstinline{pkg_resources.iter_entry_points('indico.ext')} über diese Objekte iterieren und
die entsprechenden Plugins laden.

Plugins können über reguläre Ausdrücke Code für bestimmte URLs ausführen, sodass sie auch eigene
Seiten hinzufügen können; in der Regel folgt die URL-Struktur dabei den \emph{mod\_python}-URLs,
d.h. \emph{something.py} bzw. \emph{something.py/someAction}. Daneben können Plugins sowohl
Funktionen für die JSON-RPC-API als auch Endpoints für die REST-basierte Export-API registrieren.

\end{description}
