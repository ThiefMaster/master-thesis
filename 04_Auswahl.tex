\chapter{Auswahl eines Frameworks}

\section{Migrationspfade}
Sowohl die einzelnen Frameworks als auch die Kombination eines dieser Frameworks mit Teilen des
Indico-Frameworks haben spezifische Vor- und Nachteile. Im Folgenden werden sowohl der vollständige
Umstieg auf ein bestimmtes Framework als auch Hybridlösungen vorgestellt und bewertet.

Der Vollständigkeit halber wird auch die - zugegeben sehr unwahrscheinliche - Option, komplett bei
der bestehenden Lösung zu bleiben, kurz betrachtet.

\subsection{Weiternutzung des Indico-Frameworks}
Getreu dem Motto \enquote{never change a running system} stellt sich natürlich die Frage, ob sich
der nicht zu unterschätzende Aufwand, eine komplexe Software wie Indico auf ein neues Framework
umzustellen, überhaupt lohnt. Diese Frage ist im Fall von Indico aus verschiedenen Gründen zu
bejahen. Insbesondere die Kombination aus einem sehr einfachen Routingsystem und dem
URL-Dateisystem-Mapping im CGI-Stil bietet bei der Entwicklung neuer Features diverse Nachteile:
Sofern das neue Feature eine für den Benutzer direkt zugängliche Seite besitzt ist aus Gründen der
Einheitlichkeit eine \emph{*.py}-URL angebracht. Im Falle eines neuen Moduls wie beispielsweise der
HTTP-API ist dies jedoch nicht gegeben, weshalb sich dort anbietet, ein neues Pfadsegment
einzuführen und über dieses alle Anfragen in das entsprechende Modul zu routen, was jedoch bedeutet,
dass jegliches weitere Routing von dem jeweiligen Modul übernommen werden muss.

Ein enormer Vorteil bei der bestehenden Lösung ist natürlich, dass sie seit Jahren relativ stabil
läuft und von einer breiten Userbasis benutzt wird und damit die \enquote{Kinderkrankheiten} eines
neuen Systems nicht vorhanden sind. Ebenfalls ist beispielsweise die ZODB-Datenbank stark in das
aktuelle System integriert, wobei anzumerken ist, dass dabei teilweise fast derselbe Code an
mehreren Stellen verwendet wird: Die \lstinline{RH}-Klassen und die JSON-RPC-API verwenden jeweils
dasselbe Retry-System, um Datenbankkonflikte zu behandeln, jedoch ist es in den jeweiligen Klassen
unabhängig voneinander implementiert.

Ein Vorteil beim Verzicht auf ein neues Framework wäre natürlich auch, die dafür notwendige
Entwicklungszeit anderweitig nutzen zu können. Dies ist jedoch nur kurzfristig gesehen ein Vorteil,
da die Nichtnutzung eines modernen Frameworks in Zukunft bei neuen Features mit hoher
Wahrscheinlichkeit zu deutlich mehr Entwicklungsaufwand führt als mit einem entsprechenden Framework
notwendig wäre.

Insbesondere aufgrund dieser Folge ist ein neues Framework also unbedingt notwendig. Daher wird die
Option, weiterhin ausschließlich das Indico-Framework, in den folgenden Abschnitten nicht mehr
betrachtet.


\subsection{Vollständige Migration zu Django}
Aufgrund der Struktur von Django - mehrere möglichst in sich abgeschlossene Apps - und der
empfohlenen Verzeichnisstruktur in den einzelnen Apps ist es schwierig, Django in die bestehende
Indico-Codebasis zu integrieren. Es ist deutlich einfacher und auch sauberer, das Django-Projekt in
einem neuen Verzeichnis unabhängig von der bestehenden Codebasis zu integrieren. Danach müssen
zunächst die in der gesamten Anwendung genutzten Funktionen wie beispielsweise das Benutzer- und
Gruppensystem samt LDAP-Anbindung unter Verwendung der Django-User-App neu implementiert werden.
Obwohl beispielsweise das bestehende Benutzersystem nicht Teil des Frameworks ist und durchaus in
das Django-Projekt übernommen werden könnte, hat die Neuimplementierung den Vorteil, dass die
Django-Infrastruktur im weiteren Verlauf möglichst effizient benutzt werden kann. Da die Benutzer in
der ZODB abgespeichert werden, muss diese Datenbank auch in Django integriert werden; dazu bietet
sich möglicherweise \emph{Django-ZODB} an - dies muss jedoch genauer untersucht werden, da unter
anderem Datenbankkonflikte während eines Commits sauber abgefangen werden sollten. Eine Alternative
wäre natürlich der Umstieg auf eine relationale Datenbank unter Verwendund des ORM-Systems von
Django, allerdings würde dies die bereits sehr aufwändige Migration noch komplexer machen.

Sobald der Kern der Django-Version von Indico funktionsfähig ist, kann die eigentliche Anwendung
migriert werden. Da Indico mit den \lstinline{RH}-Klassen bereits klassenbasierte Views nutzt und
oftmals auch Vererbung nutzt, bietet es sich in den meisten Fällen an, auch weiterhin Klassen statt
einfacher Funktionen zu nutzen. Während die meiste Anwendungslogik dieser Klassen übernommen werden
kann, sind dennoch in fast allen Fällen Änderungen angebracht, um beispielsweise über die von Django
bereitgestellten Variablen auf HTTP-Parameter und dynamische Elemente aus der URL zuzugreifen.
Zusammen mit dem Umstieg auf die Django-Templateengine führt dies also dazu, dass hunderte von
Klassen und Templates angepasst werden müssen. Letzteres kann teilweise automatisiert werden, die
Klassen müssen jedoch manuell umgeschrieben werden.

Für das URL-Routing müssen entsprechende Regeln in Form regulärer Ausdrücke geschrieben werden.
Indico besitzt ca. 700 verschiedene URLs, die zwar oftmals dieselben Parameter wie die ID des Events
nethalten und damit dank der \lstinline{include()}-Funktion des Routingsystems vereinfacht werden
können, aber dennoch manuell in \emph{clean URLs} umgeschrieben werden müssen - die Entscheidung,
beispielsweise statt \emph{/conferenceTimetable.py/pdf} die URL \emph{/event/123/timetable.pdf} zu
nutzen, kann keine Software übernehmen. Zusätzlich zu den neuen URLs müssen für alle direkt
verlinkbaren Seiten auch die alten URLs weiterhin unterstützt werden, um beispielsweise Links von
anderen Seiten oder Suchmaschinen nicht in einer Fehlermeldung enden zu lassen.

Zusammenfassend kann man sagen, dass es sich bei dieser Migration um ein extrem aufwändiges und
zeitintensives Unterfangen handelt, das schon eher ein Rewrite als eine Migration ist - insbesondere
wenn man es mit einem Wechsel von der bestehenden Objektdatenbank auf eine relationale Datenbank.
kombiniert. Am Ende führt der Umstieg jedoch zu sauberem Code, der sowohl leicht wartbar ist als
auch für neue Entwickler einen einfachen Einstieg ermöglicht, da viele Python-Entwickler bereits mit
Django vertraut sind.
