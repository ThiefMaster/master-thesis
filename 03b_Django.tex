\section{Django}\label{frameworks-django}

\emph{Django}\footnote{\href{https://www.djangoproject.com}{https://www.djangoproject.com}} ist das
wohl bekannteste und funktionsreichste Full-Stack-Webframework für Python. \emph{Full-Stack}
bedeutet dabei, dass alle für eine typische Webanwendung wichtigen Komponenten wie Datenbankzugriff,
Routing, Templates und Sessions vom Framework bereitgestellt werden.

Es ist primär auf \emph{Rapid Application Development} ausgelegt und wird daher von den Entwicklern
auch mit dem Slogan \enquote{for perfectionists with deadlines} beworben. Wie für RAD-Frameworks
typisch bietet Django über das Management-Tool \emph{django-admin.py} diverse
Scaffolding-Funktionen, d.h. die Möglichkeit, die Grundstruktur für ein neues Projekt bzw. neue
Module innerhalb eines Projekts automatisch zu generieren.

Die Entwicklung von Django begann 2003, wobei die erste Open-Source-Version 2005 veröffenlicht
wurde. Seitdem wurde das Framework konstant weiterentwickelt und ist derzeit in der Version 1.6
verfügbar, die unter anderem Kompatibilität mit Python 3 bietet.


\begin{description}
\item[Modularität] \hfill \\
Django bietet Modularität in verschiedenen Schichten. Bei der Webanwendung, die der Benutzer sieht
handelt es sich - um bei der in der Django-Dokumentation genutzten Terminologie zu bleiben - um das
\emph{Project}. Dabei handelt es sich um ein in der Regel in sich abgeschlossenes Projekt, das die
Konfiguration sowohl für Django selbst, die genutzte Datenbank und die Anwendung enthält. Ein
\emph{Project} enthält eine oder mehrere \emph{Apps}, wobei es sich bei jeder App um ein
Python-Paket handelt, das Datenbankmodelle, View-Funktionen, Templates und Anwendungslogik enthält.
Der Vorteil darin, viele kleine Apps statt einer großen zu nutzen, liegt darin, dass in sich
abgeschlossene Funktionalität wie beispielsweise Tagging oder auch ein Loginsystem sauber von dem
restlichen Projekt abgegrenzt ist und damit in der Regel wiederverwendbar ist. Dies wird von Django
insofern unterstützt, dass auch problemlos Apps aus anderen Projekten eingebunden werden können und
jede App in der Regel unabhängig von ihrem \emph{Project} ist sofern die nötigen Konfigurationsdaten
vorhanden sind. Django selbst enthält diverse Apps für optionale Zusatzfunktionen wie beispielsweise
eine Benutzerverwaltung und eine Kommentarfunktion.

Unabhängig von den installierten Apps bietet Django den Middleware-Stack, über den auf einer relativ
niedrigen Ebene in die Abarbeitung von Requests eingegriffen werden kann.
\lstinline{process_request} ermöglicht es der Middleware, vor dem Routing eines Requests
einzugreifen und entweder die reguläre Verarbeitung fortsetzen oder sie mit einer HTTP-Antwort
vorzeitig beenden. Dies bietet sich beispielsweise an, um Seiten anhand der aufgerufenen URL zu
cachen. \lstinline{process_view} verhält sich ähnlich, allerdings ist zu dem Zeitpunkt, wo dieser
Middleware-Hook ausgeführt wird, bereits bekannt, welche View-Funktion den Request abarbeiten wird.

Middleware hat außerdem die Möglichkeit, nach der Verarbeitung eines Requests einzugreifen. Dazu
stehen die Methoden \lstinline{process_response} und \lstinline{process_exception} zur Verfügung.
Diese könnten beispielsweise einen Cache aktualisieren oder einen webbasierten Debugger starten.


\item[URL-Routing] \hfill \\
Django legt großen Wert auf saubere URLs, die weder Dateiendungen noch kryptische Elemente wie
beispielsweise \emph{/0,2097,1-1-1928,00} enthalten. Aus diesem Grund bietet Django ein flexibles
und mächtiges Routingsystem. Da der Kern des Routingsystems der Vergleich von definierten Mustern
mit der aufgerufdenen URL ist bieten sich reguläre Ausdrücke perfekt dazu an und werden
dementsprechend auch dazu verwendet.

Der Entwickler definiert in seiner App dazu eine Liste mit \emph{Patterns}, wobei jedes Element aus
einem regulären Ausdruck und der View-Funktion, wobei es sich bei letzterem entweder direkt um die
Funktion handeln kann oder aber um einen String der Form \lstinline{'myapp.views.somefunc'}. Für
dynamische Elemente in der URL wird das Gruppierungs-Feature der Regex-Engine verwendet. Dies
bedeutet, dass beispielsweise \lstinline{r'news/(\d+)'} eine URL nach dem Schema \emph{news/123}
matchen würde und die Zahl als positionalen Parameter an die View-Funktion übergibt. Da dies gerade
in komplexeren URLs mit mehreren Parametern schnell unübersichtlich würde, können auch Namen für die
Parameter in der Form \lstinline{r'news/(?P<id>\d+)'} vergeben werden. Diese werden dann als Keyword
Arguments an die View-Funktion übergeben.

Es ist zu erwähnen, dass das Routing ausschließlich die regulären Ausdrücke benutzt und somit nur
den Pfad in der URL berücksichtigt. Das HTTP-Verb, also meist \emph{GET} oder \emph{POST} und der
Domainname sind also nicht Teil des Routings.

Insbesondere mit Apps, die zusätzliche Funktionalität wie beispielsweise eine Kommentarfunktion
bereitstellen, würde es dem Prinzip der sauberen URLs widersprechen, alle URLs auf der Rootebene zu
registrieren. Dazu bietet Django die \lstinline{include()}-Funktion mit der eine anstelle auf eine
View-Funktion auch auf eine andere URL-Routingtabelle verwiesen werden kann.

Um anhand der View-Funktion oder eines optionalen Identifiers eine URL zu generieren bietet Django
sowohl die Python-Funktion \lstinline{reverse()} als auch eine spezielle Syntax für Templates. Ganz
im Sinne von DRY führt dies dazu, dass URLs niemals manuell erzeugt werden müssen und Änderungen
keine toten internen Links zur Folge haben, da Dispatching und URL-Generierung beide auf dieselben
Routingtabellen zugreifen.

\end{description}
