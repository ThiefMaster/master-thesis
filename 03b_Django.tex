\section{Django}\label{frameworks-django}

\emph{Django}\footnote{\href{https://www.djangoproject.com}{https://www.djangoproject.com}} ist das
wohl bekannteste und funktionsreichste Full-Stack-Webframework für Python. \emph{Full-Stack}
bedeutet dabei, dass alle für eine typische Webanwendung wichtigen Komponenten wie Datenbankzugriff,
Routing, Templates und Sessions vom Framework bereitgestellt werden.

Es ist primär auf \emph{Rapid Application Development} ausgelegt und wird daher von den Entwicklern
auch mit dem Slogan \enquote{for perfectionists with deadlines} beworben. Wie für RAD-Frameworks
typisch bietet Django über das Management-Tool \emph{django-admin.py} diverse
Scaffolding-Funktionen, d.h. die Möglichkeit, die Grundstruktur für ein neues Projekt bzw. neue
Module innerhalb eines Projekts automatisch zu generieren.

Die Entwicklung von Django begann 2003, wobei die erste Open-Source-Version 2005 veröffenlicht
wurde. Seitdem wurde das Framework konstant weiterentwickelt und ist derzeit in der Version 1.6
verfügbar, die unter anderem Kompatibilität mit Python 3 bietet.


\begin{description}
\item[Modularität] \hfill \\
Django bietet Modularität in verschiedenen Schichten. Bei der Webanwendung, die der Benutzer sieht
handelt es sich - um bei der in der Django-Dokumentation genutzten Terminologie zu bleiben - um das
\emph{Project}. Dabei handelt es sich um ein in der Regel in sich abgeschlossenes Projekt, das die
Konfiguration sowohl für Django selbst, die genutzte Datenbank und die Anwendung enthält. Ein
\emph{Project} enthält eine oder mehrere \emph{Apps}, wobei es sich bei jeder App um ein
Python-Paket handelt, das Datenbankmodelle, View-Funktionen, Templates und Anwendungslogik enthält.
Der Vorteil darin, viele kleine Apps statt einer großen zu nutzen, liegt darin, dass in sich
abgeschlossene Funktionalität wie beispielsweise Tagging oder auch ein Loginsystem sauber von dem
restlichen Projekt abgegrenzt ist und damit in der Regel wiederverwendbar ist. Dies wird von Django
insofern unterstützt, dass auch problemlos Apps aus anderen Projekten eingebunden werden können und
jede App in der Regel unabhängig von ihrem \emph{Project} ist sofern die nötigen Konfigurationsdaten
vorhanden sind. Django selbst enthält diverse Apps für optionale Zusatzfunktionen wie beispielsweise
eine Benutzerverwaltung und eine Kommentarfunktion.

Unabhängig von den installierten Apps bietet Django den Middleware-Stack, über den auf einer relativ
niedrigen Ebene in die Abarbeitung von Requests eingegriffen werden kann.
\lstinline{process_request} ermöglicht es der Middleware, vor dem Routing eines Requests
einzugreifen und entweder die reguläre Verarbeitung fortsetzen oder sie mit einer HTTP-Antwort
vorzeitig beenden. Dies bietet sich beispielsweise an, um Seiten anhand der aufgerufenen URL zu
cachen. \lstinline{process_view} verhält sich ähnlich, allerdings ist zu dem Zeitpunkt, wo dieser
Middleware-Hook ausgeführt wird, bereits bekannt, welche View-Funktion den Request abarbeiten wird.

Middleware hat außerdem die Möglichkeit, nach der Verarbeitung eines Requests einzugreifen. Dazu
stehen die Methoden \lstinline{process_response} und \lstinline{process_exception} zur Verfügung.
Diese könnten beispielsweise einen Cache aktualisieren oder einen webbasierten Debugger starten.


\item[URL-Routing] \hfill \\
Django legt großen Wert auf saubere URLs, die weder Dateiendungen noch kryptische Elemente wie
beispielsweise \emph{/0,2097,1-1-1928,00} enthalten. Aus diesem Grund bietet Django ein flexibles
und mächtiges Routingsystem. Da der Kern des Routingsystems der Vergleich von definierten Mustern
mit der aufgerufdenen URL ist bieten sich reguläre Ausdrücke perfekt dazu an und werden
dementsprechend auch dazu verwendet.

Der Entwickler definiert in seiner App dazu eine Liste mit \emph{Patterns}, wobei jedes Element aus
einem regulären Ausdruck und der View-Funktion, wobei es sich bei letzterem entweder direkt um die
Funktion handeln kann oder aber um einen String der Form \lstinline{'myapp.views.somefunc'}. Für
dynamische Elemente in der URL wird das Gruppierungs-Feature der Regex-Engine verwendet. Dies
bedeutet, dass beispielsweise \lstinline{r'news/(\d+)'} eine URL nach dem Schema \emph{news/123}
matchen würde und die Zahl als positionalen Parameter an die View-Funktion übergibt. Da dies gerade
in komplexeren URLs mit mehreren Parametern schnell unübersichtlich würde, können auch Namen für die
Parameter in der Form \lstinline{r'news/(?P<id>\d+)'} vergeben werden. Diese werden dann als Keyword
Arguments an die View-Funktion übergeben.

Es ist zu erwähnen, dass das Routing ausschließlich die regulären Ausdrücke benutzt und somit nur
den Pfad in der URL berücksichtigt. Das HTTP-Verb, also meist \emph{GET} oder \emph{POST} und der
Domainname sind also nicht Teil des Routings.

Insbesondere mit Apps, die zusätzliche Funktionalität wie beispielsweise eine Kommentarfunktion
bereitstellen, würde es dem Prinzip der sauberen URLs widersprechen, alle URLs auf der Rootebene zu
registrieren. Dazu bietet Django die \lstinline{include()}-Funktion mit der eine anstelle auf eine
View-Funktion auch auf eine andere URL-Routingtabelle verwiesen werden kann.

Um anhand der View-Funktion oder eines optionalen Identifiers eine URL zu generieren bietet Django
sowohl die Python-Funktion \lstinline{reverse()} als auch eine spezielle Syntax für Templates. Ganz
im Sinne von DRY führt dies dazu, dass URLs niemals manuell erzeugt werden müssen und Änderungen
keine toten internen Links zur Folge haben, da Dispatching und URL-Generierung beide auf dieselben
Routingtabellen zugreifen.


\item[Template-Engine] \hfill \\
Django verwendet eine eigene Templateengine, die speziell für das Framework entwickelt wurde und
dementsprechend gut integriert ist. Sie unterstützt alle von einer modernen Templateengine
erwarteten Features und ermöglicht direkten Zugriff auf das Routingsystem bzw. die dazu gehörende
URL-Generierung von Django. Aus Sicherheitsgründen werden alle dynamischen Daten in HTML-Templates
escaped, sofern es nicht explizit deaktiviert wird.

Da es sich bei Templates offensichtlich um die Präsentationsschicht handelt und dort höchstens
ausgabespezifische Logik vorhanden sein soll, ist es in Django-Templates nicht möglich, Python-Code
direkt einzubinden. Allerdings können Python-Funktionen in Templates zugänglich gemacht werden und
beliebige Methoden von übergebenen Python-Objekten ausgeführt werden.

\lstinputlisting[caption=Django-Template]{code/django.tpl}


\item[Datenbankanbindung] \hfill \\
Django enthält ein ORM-System, welches die meisten verbreiteten relationalen Datenbanksysteme wie
PostgreSQL, MySQL, Oracle und SQLite offiziell unterstützt und über inoffizielle Zusatzmodule auch
weitere Datenbanken wie den Microsoft SQL Server nutzen kann.

Während es bei einer neuen Anwendung üblich ist, die Model-Klassen für die Datenbanktabellen manuell
zu erstellen und im Anschluss auf diesen basierend die Tabellen zu erstellen, bietet Django auch die
Möglichkeit, eine existierende Datenbank zu analysieren und die dazu passenden Klassen zu
generieren.

Teile von Django selbst benötigen eine mit dem Django-ORM kompatibel SQL-Datenbank. Allerdings gibt
es beispielsweise die Django-Erweiterung \emph{Django-ZODB} um die ZODB für Anwendungsdaten nutzen
zu können.


\item[Sessions] \hfill \\
Das Session-System von Django ist zwar Teil des \lstinline{django}-Pakets, allerdings ist es nicht
Teil des Django-Kerns sondern als App und Middleware realisiert, was ein gutes Beispiel für die
Modularität des Frameworks ist. Wenn es aktiviert ist stellst es in \lstinline{request.session} ein
\lstinline{dict}-artiges Objekt bereit, über das auf die Daten der Session zugegriffen werden kann.
Bei \lstinline{request} handelt es sich um den an jede View-Funktion übergebenen Parameter, über den
auf alle zum aktuellen Request gehörenden Daten zugegriffen werden kann.

Die meisten Eigenschaften der Session-App können konfiguriert werden was sie sehr flexibel macht.
Insbesondere können verschiedene Storage-Backends verwendet werden - u.a. einen Cache wie
\emph{memcached}, signierte Cookies oder eine Tabelle in der Datenbank - und man hat die Wahl
zwischen \emph{Pickle}, \emph{JSON} oder einer eigenen Implementierung bei der Serialisierung der
Sessiondaten. Letzteres ist insbesondere bei clientseitigen Cookie-Sessions wichtig, da es sich bei
\emph{Pickle} zwar um ein sehr mächtiges Format handelt, das fast jeden Python-Datentyp
serialisieren kann, diese Flexibilität jedoch zur Folge hat, dass beim Deserialisieren auch
beliebiger Code ausgeführt werden kann. Durch die kryptografische Signatur kann ein Benutzer zwar
prinzipiell keine bösartigen Daten als gültiges Sessioncookie übermitteln, allerdings führt ein Leak
des geheimen Schlüssels sofort auch zu einer \emph{Remote Code Execution}-Lücke, da mit diesem
Schlüssel gültige Cookiesignaturen erstellt werden können.

Seitens der Entwickler wird das Cache-Backend empfohlen; in diesem Fall bietet sich der
Pickle-Serializer an, da bei dieser Kombination sowohl die hohe Performance des Caches als auch die
Flexibilität von Pickle zur Verfügung stehen und der Client niemals mit den Sessiondaten in
Berührung kommt und somit keine Möglichkeit hat, sie zu manipulieren.

Das Sessionmodul nutzt unabhängig vom Backend ein Cookie; entweder zum Speichern des einzigartigen
Session-Identifiers oder für die Daten selbst. Dies hat zur Folge, dass das Session-System bei
deaktivierten Cookies nicht funktioniert. Dies ist heutzutage allerdings kein relevantes Problem
mehr, da fast jede Website spätestens beim Login Cookies voraussetzt.


\end{description}
