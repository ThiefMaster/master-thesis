\chapter{Migration zu Flask}
Bei der Migration zu Flask sind einige Schritte am Anfang zwingend notwendig, während andere
optional sind und in relativ beliebiger Reihenfolge ausgeführt werden können. Im Folgenden
werden die Migrationsschritte in der Reihenfolge beschrieben, wie sie durchgeführt wurden.


\section{Vorbereitung}
In der Vorbereitungsphase wird Flask eingebunden und lauffähig konfiguriert. Sollten dabei jedoch
Konflikte auftreten, werden diese bereits - möglichst unter Nutzung von Features des Frameworks -
behoben. Es findet zu diesem Zeitpunkt jedoch noch keine Migration statt. Das Endziel dieser Phase
ist ein temporärer Wrapper, der die \emph{mod\_python}-Funktionen über Flask aufruft, sodass
grundsätzliche Inkompatibilitäten zwischen Flask und dem Indico-Code zu Beginn der nächsten Phase
beseitigt werden können.


\subsection{Installieren von Flask}
Um einem Python-Projekt eine neue Abhängigkeit hinzuzufügen gibt es grundsätzlich zwei
Möglichkeiten. Insbesondere für Python-Libraries und andere über PyPi\footnote{Python Package Index,
\href{https://pypi.python.org}{https://pypi.python.org}} veröffentlichte Packages nutzt man eine
Datei \emph{setup.py}, in der unter anderem die Funktion \lstinline{setup()} aufgerufen wird, an die
neben diversen anderen Metadaten über den Parameter \lstinline{install_requires} die zur
Installation benötigten Pakete übergeben werden. Dies ermöglicht es Paketmanagern, die notwendigen
Abhängigkeiten automatisch zu installieren. Die Alternative zur \emph{setup.py} ist die
\emph{requirements.txt}-Datei. Diese enthält jeweils ein Paket pro Zeile, wobei neben dem Paketnamen
auch eine Version oder ein Verweis auf ein Versionskontrollsystem wie beispielsweise Git angegeben
werden kann. Meist wird die \emph{requirements.txt} bei Python-Anwendungen benutzt, die nicht über
PyPi installiert sondern manuell heruntergeladen werden und weitere Konfiguration benötigen. In
diesem Fall enthalten die Installationsanweisungen meist den Hinweis, die Abhängigkeiten mit den
Befehl \emph{pip install -r requirements.txt} zu installieren.

Da bei Indico ursprünglich vorgesehen war, es systemweit zu installieren und nur die
Konfigurationsdaten und sonstige dynamische Dateien bzw. Verzeichnisse außerhalb des systemweiten
Python-Verzeichnisses abzulegen, besitzt es sowohl eine \emph{setup.py} als auch eine
\emph{requirements.txt}. Daher muss Flask an beiden Stellen als Abhängigkeit definiert werden und
danach installiert werden. Dies kann entweder manuell mittels \emph{pip install Flask} geschehen
oder wie zuvor erwähnt über die \emph{requirements.txt}. Letzteres hat den Vorteil, dass Tippfehler
o.ä. direkt auffallen.

\begin{lstlisting}[caption=Auszug aus der requirements.txt von Indico,label=lst:indicoreqtxt]
git+https://github.com/miracle2k/webassets.git
Werkzeug==0.9
Flask==0.10
\end{lstlisting}

\autoref{lst:indicoreqtxt} zeigt einen Ausschnit aus der \emph{requirements.txt}, wobei unter
anderem Flask und das zugrundeliegende Werkzeug-Toolkit in der gerade aktuellen Version eingebunden
werden. Flask selbst setzt zwar bereits \lstinline{'Werkzeug>=0.7'} voraus, allerdings erlaubt dies
dem Paketmanager, eine beliebige Version ab 0.7 zu installieren. Meist ist dies kein Problem, da
gute Libraries API-Inkompatibilitäten möglichst vermeiden, allerdings ist es sicherer, dennoch von
allen genutzten Abhängigkeiten die Version festzulegen, sodass ein Benutzer exakt dieselben
Versionen nutzt, mit denen die Anwendung auch getestet wurde.


\subsection{Einbinden von Flask}

Indico enthält zwei Python-Packages: \lstinline{MaKaC} und \lstinline{indico}, wobei
\lstinline{MaKaC} alten Legacy-Code und \lstinline{indico} hauptsächlich neuen Code enthält.
Web-spezifischer Code ist im Paket \lstinline{indico.web}, weshalb es sich anbietet, für Flask ein
neues Package \lstinline{indico.web.flask} anzulegen. Um den Flask-Code innerhalb dieses Pakets
bereits im Hinblick auf die Migration und zukünftige Entwicklungen zu strukturieren, wird ein Modul
\emph{app.py} angelegt, welches die \emph{Application Factory} und den zum Initialisieren der App
notwendigen Code enthält.

Bei der \emph{Application Factory} handelt es sich um eine Funktion, die eine Flask-Instanz
erstellt, konfiguriert zurückgibt. Diese Kapselung hat den Vorteil, dass jegliche Initialisierung an
einigen wenigen Stellen stattfindet und beispielsweise für Unittests eine Instanz mit anderen
Konfigurationsoptionen erstellt werden kann. Ohne Nutzung einer Factory-Funktion würde die
Flask-Instanz zur Importzeit des Moduls erstellt werden und jedes andere Modul könnte das Objekt von
dort importieren und verändern. Zur \enquote{Laufzeit}, also während der Abarbeitung eines Requests,
macht sich der Unterschied nicht mehr bemerktbar, da Flask mit \lstinline{current_app} ein
Proxy-Objekt bereitstellt, welches jeweils auf die gerade aktive Flask-Instanz verweist.

Derzeit wird der eingebaute Webserver von Indico mittels \emph{indico\_shell --web-server}
gestartet. Zu Beginn ist es sinnvoll, über einen weiteren Kommandozeilenparameter zwischen Flask und
dem bestehenden Webserver samt dem alten Framework wählen zu können. Aufgrund des einfachen Aufbaus
von WSGI muss dazu nur entweder das bestehende \emph{application-Callable} oder das neue, von
\lstinline{make_app()} zurückgegebene, an den Webserver übergeben werden. Beim Aktualisieren des
dafür zuständigen Codes fällt auf, dass dort eine einfache WSGI-Middleware implementiert wurde, die
die WSGI-Applikation über den Indico-Konfiguration angegebenen Pfad verfügbar macht - also
beispielsweise \emph{http://localhost:8000/indico} statt nur \emph{http://localhost:8000}. Ein Blick
in die Werkzeug-Dokumentation zeigt, dass dort mit \lstinline{DispatcherMiddleware} eine fertige
Middleware enthalten ist, die diese Aufgabe ebenfalls übernehmen kann - allerdings mit weniger
benutzerdefiniertem Code. Da es sich dabei um eine sehr einfache Änderung handelt und Werkzeug
sowieso bereits eingebunden war, bietet es sich an, diese bereits zu diesem Zeitpunkt vorzunehmen.
Dazu dient die in \autoref{lst:indico-dispatcher} gezeigte Funktion. Sie akzeptiert als Parameter
eine WSGI-Anwendung - also entweder die Flask-Instanz oder die alte Indico-WSGI-Applikation und gibt
eine Anwendung zurück, die die übergebene Anwendung in dem konfigurierten Pfad verfügbar macht und
für alle anderen Pfade einen \emph{404 Not Found}-Fehler an den Client sendet. Sofern kein Pfad
konfiguriert ist gibt die Funktion direkt die App zurück, da die Middleware in diesem Fall nicht
benötigt wird.

\begin{lstlisting}[caption=Indico-WSGI-Dispatcher,label=lst:indico-dispatcher]
def make_indico_dispatcher(wsgi_app):
    baseURL = Config.getInstance().getBaseURL()
    path = urlparse.urlparse(baseURL)[2].rstrip('/')
    if not path:
        return wsgi_app
    else:
        return DispatcherMiddleware(NotFound(), {
            path: wsgi_app
        })
\end{lstlisting}

An dieser Stelle enthält Indico jetzt bereits eine lauffähige Flask-Anwendung, der man bereits zum
ersten Testen eine Hello-World-Funktion hinzufügen könnte. Allerdings kann die Anwendung
ausschließlich über den nicht für Produktionszwecke geeigneten Entwicklungswebserver gestartet
werden. Um sie auch über einen WSGI-kompatiblen externen Webserver nutzen zu können, wird eine
\emph{indico.wsgi}-Datei benötigt, die die Anwendung unter dem Namen \lstinline{application}
zugänglich macht.

\begin{lstlisting}[caption=indico.wsgi]
from indico.web.flask.app import make_app
application = make_app()
\end{lstlisting}


\subsection{Interface zu den mod\_python-Funktionen}

Beim \emph{mod\_python}-Routing verweisen URLs der Form \emph{/file.py} bzw. \emph{/file.py/func}
auf eine gleichnamige Datei und entweder die angegebene Funktion oder auf eine Funktion namens
\lstinline{index}. Der erste Parameter ist jeweils das Request-Objekt, danach folgen alle GET- und
POST-Parameter als Keyword Arguments. Der Rückgabewert der Funktion wird als Antwort-Body an den
Client gesendet.

Um ein Interface zu diesen Funktionen zu entwickeln, existieren verschiedene Möglichkeiten, die
jedoch alle auf einer Art Reflection basieren. Neben komplexen, auf dem Python-Syntaxbaum
aufbauenden, Varianten, ist die einfachste Lösung, die Dateien zu importieren und dann aus ihrem
globalen Namespace alle aufrufbaren Objekte auszufiltern. Dies ist in einer dynamischen Sprache wie
Python sehr einfach möglich: Mit \lstinline{execfile(path, globals)} bietet Python eine Funktion,
die die angegebene Datei ausführt und dabei das als \lstinline{globals} übergebene \lstinline{dict}
für alle \emph{globals}, d.h. die im aktuellen Modul verfügbaren globalen Variablen, nutzt. Nach dem
Aufruf dieser Funktion muss der Inhalt der Liste also nur noch gefiltert werden, um nicht
ausführbare Objekte zu entfernen, und enthält danach nur noch die relevanten Funktionen. Aus
Dateiname und Funktionsname kann nun mithilfe einfacher Stringoperationen eine entsprechende
Routingregel für Flask erzeugt werden.

Anders als \emph{mod\_python} übergibt Flask jedoch keine Parameter an die Viewfunktionen, sofern
die Routingregel keine solchen enthält. Daher ist eine Wrapperfunktion notwendig, welche die
eigentliche Funktion mit den richtigen Parametern aufruft. Da es sich bei Funktionen in Python um
First-Class-Objekte handelt, die ja wie in \autoref{firstclass} erwähnt zur Laufzeit erstellt und
von anderen Funktionen zurückgegeben werden können, ist dies wie man in
\autoref{lst:flask-mp-wrapper} erkennen kann sehr einfach möglich.

\begin{lstlisting}[caption=mod\_python-Wrapper-Facatory,label=lst:flask-mp-wrapper]
def create_flask_mp_wrapper(func):
    def wrapper():
        args = request.args.copy()
        args.update(request.form)
        flat_args = {}
        for key, item in args.iterlists():
            flat_args[key] = map(_to_utf8, item) if len(item) > 1 else _to_utf8(item[0])
        return func(None, **flat_args)
    return wrapper
\end{lstlisting}

Beim Aufruf dieser Funktion mit der \emph{mod\_python}-Funktion als Parameter wird eine neue
Funktion definiert und zurückgegeben, die die GET- und POST-Parameter in einem einzigen Objekt
zusammenfasst und alle Werte in UTF8 konvertiert. Dies ist nötig, da Flask Unicodestrings verwendet,
während Indico intern grundsätzlich mit UTF8-Strings arbeitet. Neben \lstinline{None}, dem
Python-Äquivalent von dem aus anderen Sprachen bekannten \lstinline{NULL}, statt des nicht mehr
verfügbaren Request-Objekts übergibt die neue Funktion zum Schluss die neue Parameterliste in der
von Indico erwarteten Form an die Originalfunktion.
